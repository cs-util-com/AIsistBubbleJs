<!-- Use the following User Stories / Requirements for the Web App “BabyStepsJs” to improve the code if needed:

- As a father I want to have a web app where I can playfully note down every time my newborn learns a new skill. I want to do this in form of a predefined "tech tree" that my baby unlocks
- I want in the tech tree to see the typical achievements my baby will unlock and also how they are connected. For example I want to see one tree item that says "Plays with her hands" with a time point of "Typically unlocked at month 3"
- I want to educate myself on what the next items in the tech tree will be that my baby will most likely start doing 
- I want to enter my babies birth date at the top center of the app so that when I unlock achievements it can automatically compare the typical achievement date vs mine and in case my baby unlocked something earlier then the typical baby display something on the tree item like "Unlocked 3 weeks early" 
- I want the web app to be a single page html file that has at the top a json with all the achievement elements of the tech tree. 
- An entry in that json probably requires these fields:
    - id (number)
    - title (string)
    - description (string)
    - icon (string, optional, if e.g. "face" -> uses the Material Icon "face")
    - typical_achievement_weeks (time in weeks when it's typically achieved)
    - follow_up_ids (array of id numbers, can be empty, follow up item that can be unlocked afterwards)
    - achievement_time_weeks (number, allow null & not in json, time in weeks when my baby unlocked the item)
    - comment (string, allow null & not in json, comment that I can make when I complete the tree item)
- the description of the tree entries should typically contain brief, research-backed tips or activity suggestions to support my baby's development related to that specific milestone.
- I want the web app to not have any backend, everything should be stored locally in my browsers local storage 
- I should be able to dump a json text file to back up my data on my computer. the content of the json text file should be formatted so that I can edit it with a text editor
- I should be able to re-import that backup and since in the backup the entire tech tree is contained  I should also be able to modify the entries or add new ones. so the entire used state of the tech tree should be in the file. This should be the only way to modify the tech tree content 
- As a father, I want to visualize my baby's progress on the tech tree, with unlocked achievements highlighted and connected pathways illuminated, so I can easily see which milestones have been reached and what lies ahead.
- I want the app to be minimalistic and contain mainly the birth date at the top center and the rest of the app should be the interactive tech tree that I can pan around, zoom in and out of and interact with the tree items
- I want the tech tree UI to automatically arrange itself 
- If there is an item that is typically achieved after 3 weeks but the birth date is already 4 weeks ago then color the related node in a different color
- Make sure the text in the nodes stays inside of the nodes
- Highlight nodes that will be unlocked next in a different color. A node will likely be unlocked next if the previous node is already unlocked. 
- Once the user completes an achievement, the colors are refreshed to highlight the next unlockable node. 
- If a node is clicked the UI with details should show in a side panel (not a popup) and the user should be able to enter the date when it was achieved and an optional comment 
- When the user clicks a node and the side panel opens fill in the current date for the date when the achievement was unlocked
- If the side panel is open and the user clicks somewhere outside of the side panel, close it. This way also no dedicated “close” button is needed 
- The birth date the user enters at the top center should also be stored into the local storage and reloaded on app start 
- When the user selects a node that is already completed, load the date and comment from the data when it was unlocked into the side panel ui that opens
- Based on the entered birthdate show also the current week the baby is in in the top header bar (right next to the date) 
- The UI for each node should not be a circle, it should be a rounded rectangle with the caption on the top left, the week info on the bottom left and the optional icon on the right center (being quite large and if overlap happens behind the text). The icon should be grayish to not distract too much
- The default data that should be loaded if no data is found in the storage should be loaded from https://raw.githubusercontent.com/cs-util-com/BabyStepsJs/refs/heads/main/defaultData.json.txt

Please keep this comment block in the code.
Simplify the code if possible (without removing the functionality described above). Keep all my comments even if you think they are redundant.
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>BabyStepsJs</title>

  <!-- D3 -->
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <!-- Material Icons -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
  <style>
    html, body {
      margin: 0; padding: 0; overflow: hidden;
      background-color: #1e1e2f; font-family: Arial, sans-serif;
    }

    /* TOP PANEL */
    .top-panel {
      position: absolute; width: 100%; top: 10px;
      z-index: 999; color: white; font-size: 14px;
      display: flex; justify-content: center; align-items: center; gap: 20px;
    }
    .top-panel .birthdate-container {
      display: flex; align-items: center; gap: 8px;
    }
    .top-panel input[type="date"] {
      color: black; padding: 5px 8px; border-radius: 5px; border: none;
    }
    .top-panel button {
      cursor: pointer; padding: 5px 10px; border-radius: 5px; border: none;
      background-color: #4caf50; color: white; font-weight: bold;
    }
    .top-panel button:hover { background-color: #388e3c; }
    .top-panel input#importFile { display: none; }

    /* SIDE PANEL */
    .side-panel {
      position: absolute; top: 60px; right: 0; width: 300px;
      height: calc(100% - 60px); background-color: #2c2c3e; color: #fff;
      border-left: 1px solid #444; padding: 20px; box-sizing: border-box;
      display: none; flex-direction: column; gap: 10px; font-size: 14px;
    }
    .side-panel h2 { margin: 0; font-size: 16px; }
    .side-panel textarea {
      width: 100%; height: 80px; resize: vertical; border: none;
      border-radius: 4px; font-family: Arial, sans-serif; padding: 5px;
    }
    .side-panel input[type="date"], .side-panel button {
      margin-top: 5px; padding: 5px; border-radius: 4px; border: none; color: black;
    }
    .side-panel button.save-btn {
      background-color: #4caf50; color: white; font-weight: bold;
      cursor: pointer; width: 100%;
    }
    .side-panel button.save-btn:hover { background-color: #388e3c; }

    /* MAIN SVG */
    svg {
      width: 100%; height: 100vh; box-sizing: border-box;
    }
    .link {
      stroke: #888; stroke-width: 2px; marker-end: url(#arrowhead);
    }

    /* Node Rectangle */
    .node-rect {
      stroke: #fff; stroke-width: 1.5px; cursor: pointer;
      /* Default locked color */
      fill: #b5ad5b;
      rx: 10;  /* Rounded corners */
      ry: 10;
    }
    /* Overdue color */
    .node-rect.overdue {
      fill: #a83232;
    }
    /* Next color */
    .node-rect.next {
      fill: #5c50d0;
    }
    /* Unlocked color */
    .node-rect.unlocked {
      fill: rgb(9, 126, 19);
    }

    /* Title text inside node */
    .title-text {
      font-size: 12px; fill: #ffffff; pointer-events: none;
    }
    /* Weeks info text inside node */
    .weeks-text {
      font-size: 10px; fill: #cccccc; pointer-events: none;
    }
    /* Icon, large and semi-transparent behind text */
    .node-icon {
      font-family: "Material Icons";
      font-size: 36px;
      fill: #b6b6b6;      /* grayish color */
      fill-opacity: 0.7;  /* more transparent */
      pointer-events: none; /* don’t block clicks */
    }
  </style>
</head>
<body>

<!-- TOP PANEL -->
<div class="top-panel">
  <div class="birthdate-container">
    <label for="birthDate">Birth Date:</label>
    <input type="date" id="birthDate"/>
    <span id="currentWeekLabel"></span>
  </div>
  <div>
    <button id="importBtn">Import</button>
    <button id="exportBtn">Export</button>
    <input id="importFile" type="file" accept=".json" />
  </div>
</div>

<!-- SIDE PANEL -->
<div class="side-panel" id="sidePanel">
  <h2 id="sidePanelTitle"></h2>
  <div id="sidePanelDescription" style="font-size: 12px; color: #ccc;"></div>
  <label for="sidePanelAchievementDate">Date Unlocked (optional):</label>
  <input type="date" id="sidePanelAchievementDate" />
  <label for="sidePanelComment">Comment:</label>
  <textarea id="sidePanelComment"
            placeholder="Enter any notes or observations..."></textarea>
  <button class="save-btn" id="sidePanelSaveBtn">Save</button>
</div>

<!-- MAIN SVG -->
<svg id="graph"></svg>

<script>
(async function main() {
  // 1) Load data from localStorage if possible
  let babyData = [];
  const savedData = localStorage.getItem("babyData");
  if (savedData) {
    try {
      const parsed = JSON.parse(savedData);
      if (Array.isArray(parsed)) {
        babyData = parsed;
      }
    } catch (e) {
      console.warn("Local storage babyData was corrupt, ignoring it.");
    }
  }

  // If no valid local data, load from remote (defaultData.json.txt)
  if (!babyData || babyData.length === 0) {
    try {
      const resp = await fetch("https://raw.githubusercontent.com/cs-util-com/BabyStepsJs/refs/heads/main/defaultData.json.txt");
      babyData = await resp.json();
    } catch (error) {
      console.error("Could not fetch baby data from remote:", error);
      // fallback if fetch fails
      babyData = [];
    }
  }

  // Attempt to load birthDate from localStorage
  const savedBirthDate = localStorage.getItem("birthDate");
  if (savedBirthDate) {
    document.getElementById("birthDate").value = savedBirthDate;
  }

  // 2) D3 SETUP
  const svg = d3.select("#graph");
  const width = window.innerWidth;
  const height = window.innerHeight;
  svg.attr("width", width).attr("height", height);

  // A group to handle pan & zoom
  const zoomG = svg.append("g");

  // Arrowhead definition
  const defs = svg.append("defs");
  defs.append("marker")
    .attr("id", "arrowhead")
    .attr("viewBox", "0 -5 10 10")
    .attr("refX", 90)
    .attr("refY", 0)
    .attr("markerWidth", 6)
    .attr("markerHeight", 6)
    .attr("orient", "auto")
    .attr("markerUnits", "strokeWidth")
    .append("path")
    .attr("d", "M0,-5L10,0L0,5")
    .attr("fill", "#888");

  svg.call(d3.zoom().on("zoom", (event) => {
    zoomG.attr("transform", event.transform);
  }));

  // Build graph data (nodes & links)
  function buildGraphData(data) {
    const validIds = new Set(data.map(d => d.id));
    return {
      nodes: data.map(d => ({ ...d })),
      links: data.flatMap(d =>
        d.follow_up_ids
          .filter(fuId => validIds.has(fuId))
          .map(fuId => ({ source: d.id, target: fuId }))
      )
    };
  }

  // Node rectangle dimensions
  const NODE_WIDTH = 180;
  const NODE_HEIGHT = 60;

  let simulation, nodeGroup, link, nodes, links;

  function renderGraph() {
    zoomG.selectAll("*").remove();

    const graphData = buildGraphData(babyData);
    nodes = graphData.nodes;
    links = graphData.links;

    // Setup force simulation
    simulation = d3.forceSimulation(nodes)
      .force("link", d3.forceLink(links).id(d => d.id).distance(160))
      .force("charge", d3.forceManyBody().strength(-1000))
      .force("center", d3.forceCenter(width / 2, height / 2))
      .force("collision", d3.forceCollide().radius(120));

    // Draw links
    link = zoomG.selectAll(".link")
      .data(links)
      .enter().append("line")
      .attr("class", "link");

    // Draw nodes (group)
    nodeGroup = zoomG.selectAll(".node")
      .data(nodes)
      .enter().append("g")
      .attr("class", "node")
      .call(d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended)
      );

    // 1) Rectangle (background)
    nodeGroup.append("rect")
      .attr("class", "node-rect")
      .attr("width", NODE_WIDTH)
      .attr("height", NODE_HEIGHT)
      .attr("x", -NODE_WIDTH / 2)
      .attr("y", -NODE_HEIGHT / 2)
      .on("click", (event, d) => {
        event.stopPropagation(); // to prevent side-panel from closing
        onNodeClick(d);
      });

    // 2) Icon (right center, behind text)
    nodeGroup.append("text")
      .attr("class", "node-icon")
      .attr("x", (NODE_WIDTH / 2) - 30)  // 30px in from right edge
      .attr("y", 0)                     // center vertically
      .attr("text-anchor", "middle")
      .attr("dominant-baseline", "middle")
      .text(d => d.icon ? d.icon : "");

    // 3) Title text (top-left corner)
    nodeGroup.append("text")
      .attr("class", "title-text")
      .attr("x", -(NODE_WIDTH / 2) + 8)     // small left padding
      .attr("y", -(NODE_HEIGHT / 2) + 16)   // some top padding
      .text(d => d.title)
      .each(function(d) { wrapText(d3.select(this), NODE_WIDTH - 40); });

    // 4) Weeks info (bottom-left corner)
    nodeGroup.append("text")
      .attr("class", "weeks-text")
      .attr("x", -(NODE_WIDTH / 2) + 8)   // left padding
      .attr("y", (NODE_HEIGHT / 2) - 8)   // bottom padding
      .text(formatWeeks);

    simulation.on("tick", () => {
      link
        .attr("x1", d => d.source.x)
        .attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x)
        .attr("y2", d => d.target.y);

      nodeGroup.attr("transform", d => `translate(${d.x},${d.y})`);
    });

    refreshGraph();
  }

  function dragstarted(event, d) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x; d.fy = d.y;
  }
  function dragged(event, d) {
    d.fx = event.x; d.fy = event.y;
  }
  function dragended(event, d) {
    if (!event.active) simulation.alphaTarget(0);
    d.fx = null; d.fy = null;
  }

  // Simple text-wrap function for node titles
  function wrapText(textSelection, width) {
    textSelection.each(function() {
      const text = d3.select(this);
      const words = text.text().split(/\s+/).reverse();
      let line = [];
      let lineNumber = 0;
      const lineHeight = 1.2; // em
      const y = text.attr("y") || 0;
      const x = text.attr("x") || 0;
      let tspan = text.text(null)
        .append("tspan")
        .attr("x", x)
        .attr("y", y)
        .attr("dy", 0 + "em");
      let word;

      while ((word = words.pop())) {
        line.push(word);
        tspan.text(line.join(" "));
        if (tspan.node().getComputedTextLength() > width) {
          line.pop();
          tspan.text(line.join(" "));
          line = [word];
          tspan = text.append("tspan")
            .attr("x", x).attr("y", y)
            .attr("dy", ++lineNumber * lineHeight + "em")
            .text(word);
        }
      }
    });
  }

  // 4) COLORING & “NEXT” / “OVERDUE”
  function refreshGraph() {
    updateCurrentWeekLabel();

    const birthDateStr = document.getElementById("birthDate").value;
    let ageInWeeks = null;
    if (birthDateStr) {
      const diffDays = (new Date() - new Date(birthDateStr)) / (1000 * 60 * 60 * 24);
      ageInWeeks = Math.floor(diffDays / 7);
    }

    nodeGroup.select("rect.node-rect")
      .each(function(d) {
        const rect = d3.select(this);
        // Remove all state classes first
        rect.classed("unlocked", false)
            .classed("overdue", false)
            .classed("next", false);

        if (d.achievement_time_weeks !== null) {
          // Unlocked
          rect.classed("unlocked", true);
        } else {
          // Still locked
          if (ageInWeeks && ageInWeeks > d.typical_achievement_weeks) {
            rect.classed("overdue", true);
          }
          // Check if 'next' (all parents unlocked)
          const parents = babyData.filter(p => p.follow_up_ids.includes(d.id));
          const allParentsUnlocked = parents.every(p => p.achievement_time_weeks !== null);
          if (parents.length === 0 || allParentsUnlocked) {
            rect.classed("next", true);
          }
        }
      });

    // Update weeks text
    nodeGroup.select(".weeks-text").text(formatWeeks);
  }

  // Return string describing how early/late an achievement was unlocked
  function formatWeeks(d) {
    if (d.achievement_time_weeks === null) {
      return `~ week ${d.typical_achievement_weeks}`;
    }
    const diff = d.typical_achievement_weeks - d.achievement_time_weeks;
    if (diff > 0) return `Unlocked ${Math.abs(diff)} weeks early`;
    if (diff < 0) return `Unlocked ${Math.abs(diff)} weeks late`;
    return `Unlocked right on time`;
  }

  // 5) SIDE PANEL
  let currentNode = null;
  const sidePanel = document.getElementById("sidePanel");
  const titleEl = document.getElementById("sidePanelTitle");
  const descEl = document.getElementById("sidePanelDescription");
  const dateEl = document.getElementById("sidePanelAchievementDate");
  const commentEl = document.getElementById("sidePanelComment");
  const saveBtn = document.getElementById("sidePanelSaveBtn");

  saveBtn.addEventListener("click", () => {
    if (!currentNode) return;
    // If user provided a date, compute baby’s age in weeks at that date
    const achievementDate = dateEl.value ? new Date(dateEl.value) : null;
    const birthDateStr = document.getElementById("birthDate").value;

    if (achievementDate && birthDateStr) {
      const bd = new Date(birthDateStr);
      const diffDays = (achievementDate - bd) / (1000 * 60 * 60 * 24);
      currentNode.achievement_time_weeks = diffDays > 0
        ? Math.round(diffDays / 7)
        : 0;
    } else if (achievementDate && !birthDateStr) {
      // No birth date => fallback
      currentNode.achievement_time_weeks = currentNode.typical_achievement_weeks;
    } else {
      // No date => treat as locked again
      currentNode.achievement_time_weeks = null;
    }

    currentNode.comment = commentEl.value.trim();
    refreshGraph();
    saveToLocalStorage();
    hideSidePanel();
  });

  function onNodeClick(d) {
    currentNode = d;
    titleEl.textContent = d.title;
    descEl.textContent = d.description;
    commentEl.value = d.comment || "";

    // If locked, fill today's date by default
    // If unlocked, reconstruct date from birth date + achievement_time_weeks
    const birthDateStr = document.getElementById("birthDate").value;
    if (d.achievement_time_weeks === null) {
      const now = new Date();
      dateEl.value = now.toISOString().split("T")[0];
    } else if (birthDateStr) {
      const bd = new Date(birthDateStr);
      const guessDate = new Date(bd);
      guessDate.setDate(guessDate.getDate() + (7 * d.achievement_time_weeks));
      dateEl.value = guessDate.toISOString().split("T")[0];
    } else {
      dateEl.value = "";
    }

    sidePanel.style.display = "flex";
  }

  function hideSidePanel() {
    sidePanel.style.display = "none";
    currentNode = null;
  }

  // Close side panel if user clicks outside it
  document.addEventListener("click", (event) => {
    if (!sidePanel.contains(event.target)) {
      hideSidePanel();
    }
  });

  // 6) SAVE & LOAD from LOCAL STORAGE
  function saveToLocalStorage() {
    localStorage.setItem("babyData", JSON.stringify(nodes.map(d => ({
      id: d.id,
      title: d.title,
      icon: d.icon,
      description: d.description,
      typical_achievement_weeks: d.typical_achievement_weeks,
      follow_up_ids: d.follow_up_ids,
      achievement_time_weeks: d.achievement_time_weeks,
      comment: d.comment
    }))));

    const bd = document.getElementById("birthDate").value;
    if (bd) {
      localStorage.setItem("birthDate", bd);
    } else {
      localStorage.removeItem("birthDate");
    }
  }

  // 7) IMPORT / EXPORT
  document.getElementById("exportBtn").addEventListener("click", () => {
    // Prepare data for export (entire tech tree + states)
    const exportData = JSON.stringify(babyData, null, 2);
    const blob = new Blob([exportData], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "babyData_backup.json";
    a.click();
    URL.revokeObjectURL(url);
  });

  document.getElementById("importBtn").addEventListener("click", () => {
    document.getElementById("importFile").click();
  });

  document.getElementById("importFile").addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
      try {
        const importedData = JSON.parse(ev.target.result);
        if (!Array.isArray(importedData)) {
          alert("JSON must be an array of items.");
          return;
        }
        babyData = importedData;
        localStorage.setItem("babyData", JSON.stringify(babyData));
        renderGraph();
      } catch (err) {
        alert("Error parsing JSON. Check file format.");
      }
    };
    reader.readAsText(file);
    e.target.value = null;
  });

  // 8) HELPER: Update “Current Week” label
  function updateCurrentWeekLabel() {
    const birthDateStr = document.getElementById("birthDate").value;
    const label = document.getElementById("currentWeekLabel");
    if (!birthDateStr) {
      label.textContent = "";
      return;
    }
    const diffDays = (new Date() - new Date(birthDateStr)) / (1000 * 60 * 60 * 24);
    const ageInWeeks = Math.floor(diffDays / 7);
    label.textContent = `(Week ${ageInWeeks})`;
  }

  // 9) RE-RENDER ON BIRTHDATE CHANGE
  document.getElementById("birthDate").addEventListener("change", () => {
    saveToLocalStorage();
    refreshGraph();
  });

  // 10) INITIAL RENDER
  renderGraph();
})();
</script>
</body>
</html>